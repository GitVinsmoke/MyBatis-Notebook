# MyBatis的一个简单示例

MyBatis版本：3.4.6

在使用MyBatis做一个简单实用示例之前，为了规范，我们还是需要考虑两个问题：第一个，DAO模式；第二个，MyBatis对象的作用域。

我们暂且把这个示例分为两层，一个服务层，一个是DAO层，DAO层DAO接口及其实现类，DAO中包含了暴露给服务层调用的方法。

在作用域的问题上，我们让SqlSessionFactory保持单例，并采用 initialization on demand holder技术来实现单例模式，由于SqlSession的实例是线程不安全的，不能被共享，所以我们把它放在方法作用域中，在Dao层的方法中。

##### 1. 准备工作

导入相关的JAR包（包含Mybatis以及log4j的）。

##### 2. SqlSessionFactory工具类

另外，我们还可以把创建SqlSessionFactory的过程抽取出来，使用一个SqlSessionFactoryUtils工具类，共享SqlSessionFactory创建过程，因为在官方文档中也推荐SQLSessionFactory采用单例模式，下面我们将采用 initialization on demand holder 技术来实现这个单例模式，既保证线程安全又保证延迟加载。

```java
package com.li.common;

import java.io.IOException;
import java.io.InputStream;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

/*SqlSessionFactory工具类，将使用单例模式创建SqlSessionFactory*/

public class SqlSessionFactoryUtils {
	
	private static class SqlSessionFactoryClass{
	
		static {
			System.out.println("创建SqlSessionFactory对象的静态代码块执行了！");
			
			// 1. 创建SqlSessionFactoryBuilder对象
			SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder();
			try {
				// 2. 加载SqlMapConfig.xml配置文件
				InputStream inputStream=Resources.getResourceAsStream("SqlMapConfig.xml");
				// 3. 创建SqlSessionFactory对象
				sessionFaction=builder.build(inputStream);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		
		public static SqlSessionFactory sessionFaction;
	}

	public static SqlSessionFactory getSqlSessionFactory() {
		return SqlSessionFactoryClass.sessionFaction;
	}
	
	public static void main(String[] args) {
		System.out.println(SqlSessionFactoryUtils.getSqlSessionFactory());
	}
}

```

##### 3. 一个POJO类

Student类，位于 src （source folder）下的 com.li.student.domain 包下。

```java
package com.li.student.domain;

public class Student {
	
	private String stu_no;
	private String stu_name;
	private Integer stu_age;
	private String stu_gender;
	public String getStu_no() {
		return stu_no;
	}
	public void setStu_no(String stu_no) {
		this.stu_no = stu_no;
	}
	public String getStu_name() {
		return stu_name;
	}
	public void setStu_name(String stu_name) {
		this.stu_name = stu_name;
	}
	public Integer getStu_age() {
		return stu_age;
	}
	public void setStu_age(Integer stu_age) {
		this.stu_age = stu_age;
	}
	public String getStu_gender() {
		return stu_gender;
	}
	public void setStu_gender(String stu_gender) {
		this.stu_gender = stu_gender;
	}
	
	public Student(String stu_no, String stu_name, Integer stu_age, String stu_gender) {
		super();
		this.stu_no = stu_no;
		this.stu_name = stu_name;
		this.stu_age = stu_age;
		this.stu_gender = stu_gender;
	}

	public Student() {
		super();
	}
	@Override
	public String toString() {
		return "Student [stu_no=" + stu_no + ", stu_name=" + stu_name + ", stu_age=" + stu_age + ", stu_gender="
				+ stu_gender + "]";
	}
	
}

```

其实应该还需要做类的属性字段和表中栏位的映射工作，但是这里为了简单，直接把属性字段写成和栏位名字相同的名称，这样可以直接映射。

##### 4. 配置文件

先在工程根目录下创建config 资源文件（source folder，就是跟src同样的文件），再在其子目录sqlmap文件中创建一个SQL映射文件Student.xml：

```xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- namespace：命名空间，用于隔离sql，还有一个很重要的作用，后面解释 -->

<mapper namespace="com.li.student.domain.StudentMapper">

	<!-- id:statement的id 或者叫做sql的id-->
	<!-- parameterType:声明输入参数的类型 -->
	<!-- resultType:声明输出结果的类型，应该填写pojo的全路径 -->
	<!-- #{}：输入参数的占位符，相当于jdbc的？ -->

	<!-- 根据ID查找 -->
	<select id="queryById" parameterType="string" resultType="com.li.student.domain.Student">
		SELECT * FROM stu_info WHERE stu_no  = #{id}
	</select>
	
	<!-- （模糊查询）返回数据集合，只需设定为每一个元素的数据类型 -->
	<select id="queryByBlurredName" parameterType="string" resultType="com.li.student.domain.Student">
		<!-- 准确查询：select * from stu_info where stu_name like #{name} -->
		select * from stu_info where stu_name like '%${value}%'
	</select>

	<!-- 插入操作 -->
	<insert id="insertStu" parameterType="com.li.student.domain.Student">
		<!-- 有多个参数，如果没有做映射关系的工作，则需要名称一样 -->
		insert into stu_info (stu_no, stu_name, stu_age, stu_gender) values(#{stu_no}, #{stu_name}, #{stu_age}, #{stu_gender});
	</insert>
	
	<!-- 删除操作 -->
	<delete id="deleteStu" parameterType="string">
		delete from stu_info where stu_no=#{id}
	</delete>

	<!-- 更新操作 -->
	<update id="updateName" parameterType="com.li.student.domain.Student">
		update stu_info set stu_name=#{stu_name} where stu_no=#{stu_no}
	</update>

</mapper>
```

再在config目录下创建一个核心配置文件SqlMapConfig.xml，用来配置数据源和事务，并且把sql映射文件配置进去管理：

```xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">

<!-- 核心配置文件 -->

<configuration>

	<!-- 环境配置，和spring整合后 environments配置将废除 -->
	<environments default="development">
		<environment id="development">
			<!-- 使用jdbc事务管理 -->
			<transactionManager type="JDBC" />
			<!-- 数据库连接池 -->
			<dataSource type="POOLED">
				<property name="driver" value="com.mysql.jdbc.Driver" />
				<property name="url" value="jdbc:mysql://localhost:3306/learning?useSSL=true" />
				<property name="username" value="root" />
				<property name="password" value="123456" />
			</dataSource>
		</environment>
	</environments>
	
	<mappers>
		<mapper resource="sqlmap/Student.xml"/>
	</mappers>
	
</configuration>

```

继上篇文章我们知道，我们还可以为SQL映射文件创建一个映射器类，该映射器类的完全限定名和SQL映射文件配置的命名空间是一样的。

```java
package com.li.student.domain;

import java.util.List;

import org.apache.ibatis.annotations.Select;

public interface StudentMapper {
	
	Student queryById(String id);
		
	@Select("SELECT * FROM stu_info WHERE stu_no  = #{id}")
	Student getById(String id);
	
	List<Student> queryByBlurredName(String name);

	void insertStu(Student s);
	
	void deleteStu(String id);
	
	void updateName(Student s);
}

```

该映射器类中有两个方法，都是通过id查找对象，但是有所不同，第一个根据SQL映射文件SQL语句的id而写的同名方法，使用该方法时，会查找映射文件；第二个在SQL映射文件中没有同名的SQL语句，但是有注解，执行的是注解的SQL语句。

出log4j.properties日志工具的配置，我们将此文件也放在config文件夹下：

```
log4j.rootLogger=DEBUG, Console
#Console
log4j.appender.Console=org.apache.log4j.ConsoleAppender
log4j.appender.Console.layout=org.apache.log4j.PatternLayout
log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n
log4j.logger.java.sql.ResultSet=INFO
log4j.logger.org.apache=INFO
log4j.logger.java.sql.Connection=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG
```

##### 持久化层

StudentDao

```java
package com.li.student.persistence;

import java.util.List;

import com.li.student.domain.Student;

public interface StudentDao {
	
	/*根据id删除学生*/
	void deleteStudent(String id);
	
	/*添加学习到数据库*/
	void save(Student s);
	
	/*通过id获取学生信息*/
	Student getById(String id);
	
	/*通过名字进行模糊查询*/
	List<Student> getByBlurredName(String name);
	
	/*更新学生姓名*/
	void updateName(Student s);
}

```

下面是Dao的实现类，StudentDaoImp。**这里我们需要注意的是，当对数据库进行更新的操作时（插入、更新或删除），我们需要提交操作，否则数据库的状态不会改变，而且还不会报错，这是一个很隐蔽的地方。**

```java
package com.li.student.persistence;

import java.util.List;

import org.apache.ibatis.session.SqlSession;

import com.li.common.SqlSessionFactoryUtils;
import com.li.student.domain.Student;
import com.li.student.domain.StudentMapper;

public class StudentDaoImpl implements StudentDao {

	@Override
	public void save(Student s) {
		SqlSession session=SqlSessionFactoryUtils.getSqlSessionFactory().openSession();
		try {
			StudentMapper mapper=session.getMapper(StudentMapper.class);
			mapper.insertStu(s);
			/*对数据库做更新操作时，如果不提交，数据库不改变而且还不会报错*/
			session.commit();
		} finally {
			session.close();
		}
	}

	@Override
	public Student getById(String id) {
		SqlSession session=SqlSessionFactoryUtils.getSqlSessionFactory().openSession();
		Student s=null;
		try {
//			s=session.selectOne("com.li.student.domain.StudentMapper.queryById", "2015");
			StudentMapper mapper=session.getMapper(StudentMapper.class);
			s=mapper.queryById("2015");
		} finally {
			session.close();
		}
		return s;
	}

	@Override
	public List<Student> getByBlurredName(String name) {
		SqlSession session=SqlSessionFactoryUtils.getSqlSessionFactory().openSession();
		List<Student> list=null;
		try {
			StudentMapper mapper=session.getMapper(StudentMapper.class);
			list=mapper.queryByBlurredName(name);
		} finally {
			session.close();
		}
		return list;
	}

	@Override
	public void deleteStudent(String id) {
		SqlSession session=SqlSessionFactoryUtils.getSqlSessionFactory().openSession();
		try {
			StudentMapper mapper=session.getMapper(StudentMapper.class);
			mapper.deleteStu(id);
			session.commit();
		} finally {
			session.close();
		}
	}

	@Override
	public void updateName(Student s) {
		SqlSession session=SqlSessionFactoryUtils.getSqlSessionFactory().openSession();
		try {
			StudentMapper mapper=session.getMapper(StudentMapper.class);
			mapper.updateName(s);
			session.commit();
		} finally {
			session.close();
		}
	}
	
}

```

##### 服务层

StudentService

```java
package com.li.student.service;

import java.util.List;

import org.apache.ibatis.session.SqlSession;

import com.li.common.SqlSessionFactoryUtils;
import com.li.student.domain.Student;
import com.li.student.persistence.StudentDao;
import com.li.student.persistence.StudentDaoImpl;

public class StudentService {
	
	private StudentDao dao;
	
	public void setDao(StudentDao dao) {
		this.dao=dao;
	}
	
	public Student getById(String id) {
		return dao.getById(id);
	}
	
	public List<Student> getByBlurredName(String name){
		return dao.getByBlurredName(name);
	}
	
	public void save(Student s) {
		dao.save(s);
	}
	
	public void deleteStudent(String id) {
		dao.deleteStudent(id);
	}
	
	public void updateName(Student s) {
		dao.updateName(s);
	}
	
	public static void main(String[] args) {
		
		StudentService ss=new StudentService();
		StudentDaoImpl impl=new StudentDaoImpl();
		ss.setDao(impl);
		
		ss.deleteStudent("1999");
		
		List<Student> list = ss.getByBlurredName("wang");
		for(Student s : list) {
			System.out.println(s);
		}
	}

}
```